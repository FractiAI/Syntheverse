# Source Code - Fractal Analysis

## Fractal Position

- Level: Layer
- Scale: Meso
- System Role: Complete three-layer architecture implementation

## Self-Similarity Patterns

### Structural Mirroring
`src/` structure mirrors the three-layer Blueprint architecture: `api/` (UI Layer bridges), `blockchain/` (Layer 1), `core/` (Layer 2), `frontend/` (UI Layer), `data/` (cross-layer state). Each subdirectory follows the same organizational pattern as parent `src/`.

### Interface Consistency
Consistent API patterns: Flask REST endpoints (`api/poc-api/`), FastAPI services (`api/rag_api/`), Web3 blockchain interfaces (`blockchain/layer1/`), component props (`frontend/poc-frontend/`), file-based state (`data/`).

### Documentation Fractals
Each `src/` subdirectory follows AGENTS.md + README.md + FRACTAL.md pattern, creating recursive documentation hierarchy that mirrors code organization.

## Recursive Organization

### Hierarchical Composition
Five functional areas compose into complete system: APIs connect layers, blockchain provides Layer 1, core handles Layer 2, frontend delivers UI, data manages state. Each area contains holographic representation of full system functionality.

### Responsibility Delegation
- `api/` bridges frontend to backend
- `blockchain/` manages Layer 1 operations
- `core/` orchestrates Layer 2 evaluation
- `frontend/` provides user interfaces
- `data/` handles persistent state

### Information Aggregation
Child components aggregate through service orchestration (`core/layer2/poc_server.py`), API routing (`api/poc-api/`), and data pipelines (`data/vectorized/`). Evaluation results flow from `core/layer2/evaluator/` through `api/poc-api/` to `frontend/poc-frontend/`.

## Holographic Properties

### Blueprint Reflection
`src/` embodies complete Blueprint implementation: Layer 1 blockchain (§3), Layer 2 evaluation (§3.2), UI Layer (§3), PoC pipeline (§3.1), AI integration (§5), and token allocation (§3.3).

### System Context
Contains holographic representation of entire ecosystem: contribution submission (`frontend/poc-frontend/`), evaluation engine (`core/layer2/`), blockchain registration (`blockchain/`), AI training (`core/layer2/poc_archive.py`), and state management (`data/`).

### Knowledge Embedding
Encodes complete operational knowledge: service endpoints (`api/`), smart contracts (`blockchain/contracts/`), evaluation algorithms (`core/layer2/evaluator/`), UI components (`frontend/poc-frontend/`), and data processing (`data/`).

## Data Flow Fractals

### Input Streams
User contributions enter through `frontend/`, API calls through `api/`, blockchain events through `blockchain/layer1/`, file uploads through `data/`. All inputs validate against consistent schemas.

### Processing Patterns
Self-similar transformation recurses: submission → archive → evaluation → qualification → allocation → integration. Pattern repeats within each layer and across layer boundaries.

### Output Structures
Consistent outputs: JSON responses (`api/`), transaction receipts (`blockchain/`), component updates (`frontend/`), state files (`data/`), evaluation results (`core/layer2/`).

## Scale Relationships

### Parent Integration
Integrates with root through startup scripts (`scripts/startup/`), environment configuration (`config/`), and documentation cross-references (`docs/`). Provides complete operational system to parent orchestration.

### Child Coordination
Orchestrates five child directories through import dependencies, service communication, and shared utilities (`core/utils/`). Dependency injection patterns maintain loose coupling.

### Sibling Communication
Horizontal integration through shared environment (`config/`), common testing (`tests/`), and unified documentation (`docs/`). Each functional area contributes to collective system operation.

## Hydrogen-Holographic Manifestation

Hydrogen-holographic principles manifest through measurable evaluation at every level: `core/layer2/evaluator/` provides fractal scoring (0-10,000 across novelty/density/coherence/alignment), `core/layer2/poc_archive.py` enables redundancy detection, `blockchain/` provides permanent anchoring, `frontend/` enables exploration, and `data/` supports continuous learning.

## Regenerative Patterns

Contributes to closed-loop regeneration through: AI training on archived contributions (`data/` + `core/layer2/`), metallic amplification rewards (`core/layer2/poc_archive.py`), token distribution (`core/layer2/tokenomics_state.py`), and permanent blockchain records (`blockchain/`). Each operational cycle strengthens the ecosystem.

## Cross-Scale Invariants

Consistent patterns across scales: service health monitoring, error handling, logging, configuration loading, and Blueprint alignment. These invariants enable fractal composition from individual functions to complete three-layer architecture.
